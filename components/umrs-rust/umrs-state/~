use std::path::{PathBuf, Path};

use clap::{Parser, Subcommand};
use umrs_core::{UmrsState, load_state, save_state};

#[derive(Parser, Debug)]
#[command(name = "umrs-state")]
struct Cli {
    #[arg(long = "state-file")]
    state_file: Option<PathBuf>,

    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand, Debug)]
enum Command {
    Get { key: String },
    Set { key: String, value: String },
    ListKeys,
}

// Enum representing all available keys
#[derive(Debug, Clone, Copy)]
enum UmrsKey {
    Purpose,
    SystemType,
    Virtualization,
}

impl UmrsKey {
    // Returns the string representation of the key
    fn as_str(&self) -> &'static str {
        match self {
            UmrsKey::Purpose => "system_metadata.purpose",
            UmrsKey::SystemType => "system_metadata.system_type",
            UmrsKey::Virtualization => "system_metadata.virtualization",
        }
    }

    // Returns all keys
    fn all() -> &'static [UmrsKey] {
        &[UmrsKey::Purpose, UmrsKey::SystemType, UmrsKey::Virtualization]
    }

    // Converts a string into a UmrsKey, if valid
    fn parse(key: &str) -> Option<UmrsKey> {
        Self::all().iter().copied().find(|k| k.as_str() == key)
    }
}

// Main Block
fn main() -> std::io::Result<()> {
    init_logging();

    let cli = Cli::parse();

    let state_path = cli
        .state_file
        .unwrap_or_else(|| PathBuf::from("/var/lib/umrs/umrs-state.json"));

    // Warn if missing before loading
    match &cli.command {
        Command::Get { .. } | Command::ListKeys => check_state_file(&state_path, false),
        Command::Set { .. } => check_state_file(&state_path, true),
    }

    // Load state (default if file missing)
    let mut state = load_state(&state_path)?;

    // Dispatch commands
    match cli.command {
        Command::Get { key } => {
            handle_get(&state, &key);
        }
        Command::Set { key, value } => {
            handle_set(&mut state, &key, &value)?;
            save_state(&state_path, &state)?;
            log_manual_set(&key, &value);
        }
        Command::ListKeys => {
            list_keys();
        }
    }

    Ok(())
}


// Initialize syslog logging
fn init_logging() {
    if let Err(e) = syslog::init_unix(syslog::Facility::LOG_AUTH, log::LevelFilter::Info) {
        eprintln!("Failed to init syslog: {e}");
    }
}

// Print all available keys
fn list_keys() {
    for key in UmrsKey::all() {
        println!("{}", key.as_str());
    }
}

fn check_state_file(path: &Path, creating: bool) {
    if !path.exists() {
        if creating {
            eprintln!(
                "State file '{}' does not exist. It will be created.",
                path.display()
            );
        } else {
            eprintln!(
                "Warning: state file '{}' does not exist. Using default state.",
                path.display()
            );
        }
    }
}


// Handle `get` command
fn handle_get(state: &UmrsState, key: &str) {
    match UmrsKey::parse(key) {
        Some(UmrsKey::Purpose) => {
            match &state.system_metadata.purpose {
                Some(p) => println!("{p}"),
                None => println!("(not set)"),
            }
        }
        Some(UmrsKey::SystemType) => {
            match &state.system_metadata.system_type {
                Some(t) => println!("{t}"),
                None => println!("(not set)"),
            }
        }
        Some(UmrsKey::Virtualization) => {
            match &state.system_metadata.virtualization {
                Some(v) => println!("{v}"),
                None => println!("(not set)"),
            }
        }
        None => eprintln!("Unknown key: {key}"),
    }
}


// Handle `set` command
fn handle_set(state: &mut UmrsState, key: &str, value: &str) -> std::io::Result<()> {
    match UmrsKey::parse(key) {
        Some(UmrsKey::Purpose) => state.system_metadata.purpose = Some(value.to_string()),
        Some(UmrsKey::SystemType) => state.system_metadata.system_type = Some(value.to_string()),
        Some(UmrsKey::Virtualization) => {
            state.system_metadata.virtualization = Some(value.to_string())
        }
        None => eprintln!("Unknown key: {key}"),
    }
    Ok(())
}

// Log manual set operations
fn log_manual_set(key: &str, value: &str) {
    let msg = format!("Manual umrs-state set: {key}={value}");
    log::info!("{}", msg);
}

