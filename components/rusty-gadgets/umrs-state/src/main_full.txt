§use std::env;
§use std::fs;
§use std::io::{self, Write};
§use std::path::Path;
§use std::process::Command;
§
§use serde_json::{json, Value};
§
§const DEFAULT_STATE_FILE: &str = “/var/lib/umrs/umrs-state.json”;
§
§fn main() {
§    if let Err(e) = run() {
§        eprintln!(“umrs-state error: {e}”);
§        std::process::exit(1);
§    }
§}
§
§fn run() -> Result<(), String> {
§    let args: Vec = env::args().skip(1).collect();
§    if args.is_empty() {
§        print_usage();
§        return Err(“no arguments provided”.into());
§    }
§
§    // Parse optional –state-file and collect remaining positional args.
§    let (state_file, positional) = parse_args_with_state_file(&args)?;
§    if positional.is_empty() {
§        print_usage();
§        return Err(“no command provided”.into());
§    }
§
§    let command = positional[0].as_str();
§    match command {
§        “get” => {
§            if positional.len() != 2 {
§                return Err(“get requires exactly one key path argument”.into());
§            }
§            let key_path = &positional[1];
§            handle_get(&state_file, key_path)
§        }
§        “set” => {
§            if positional.len() != 3 {
§                return Err(“set requires a key path and a value”.into());
§            }
§            let key_path = &positional[1];
§            let value_str = &positional[2];
§            handle_set(&state_file, key_path, value_str)
§        }
§        _ => {
§            print_usage();
§            Err(format!(“unknown command: {command}”))
§        }
§    }
§}
§
§fn print_usage() {
§    let _ = writeln!(
§        io::stderr(),
§        “Usage:
§  umrs-state [–state-file PATH] get KEY_PATH
§  umrs-state [–state-file PATH] set KEY_PATH VALUE
§
§Examples:
§  umrs-state get system_metadata.purpose
§  umrs-state set system_metadata.purpose "Production Guard"
§  umrs-state –state-file /tmp/custom-state.json get system_metadata.role”
§    );
§}
§
§fn parse_args_with_state_file(args: &[String]) -> Result<(String, Vec), String> {
§    let mut state_file = DEFAULT_STATE_FILE.to_string();
§    let mut positional: Vec = Vec::new();
§
§    let mut i = 0;
§    while i < args.len() {
§        if args[i] == “–state-file” {
§            if i + 1 >= args.len() {
§                return Err(“missing value for –state-file”.into());
§            }
§            state_file = args[i + 1].clone();
§            i += 2;
§        } else {
§            positional.push(args[i].clone());
§            i += 1;
§        }
§    }
§
§    Ok((state_file, positional))
§}
§
§fn handle_get(state_file: &str, key_path: &str) -> Result<(), String> {
§    let mut root = load_or_init_state(state_file)?;
§    ensure_object_root(&mut root)?;
§
§    match get_by_key_path(&root, key_path) {
§        Some(v) => {
§            println!(”{}”, v);
§            Ok(())
§        }
§        None => Err(format!(“key path not found: {key_path}”)),
§    }
§}
§
§fn handle_set(state_file: &str, key_path: &str, value_str: &str) -> Result<(), String> {
§    let mut root = load_or_init_state(state_file)?;
§    ensure_object_root(&mut root)?;
§
§    let new_value = parse_value(value_str);
§    set_by_key_path(&mut root, key_path, new_value)?;
§
§    save_state(state_file, &root)?;
§
§    // Log the manual set operation to syslog via logger.
§    if let Err(e) = log_manual_set(“set”, key_path, value_str, state_file) {
§        eprintln!(“umrs-state warning: failed to log to syslog: {e}”);
§    }
§
§    Ok(())
§}
§
§fn load_or_init_state(state_file: &str) -> Result<Value, String> {
§    let path = Path::new(state_file);
§    if path.exists() {
§        let data = fs::read_to_string(path)
§            .map_err(|e| format!(“failed to read state file {state_file}: {e}”))?;
§        if data.trim().is_empty() {
§            // Treat empty file as empty object.
§            Ok(json!({}))
§        } else {
§            serde_json::from_str(&data)
§                .map_err(|e| format!(“failed to parse JSON from {state_file}: {e}”))
§        }
§    } else {
§        // Initialize a new empty JSON object.
§        Ok(json!({}))
§    }
§}
§
§fn save_state(state_file: &str, root: &Value) -> Result<(), String> {
§    let path = Path::new(state_file);
§    if let Some(parent) = path.parent() {
§        if !parent.exists() {
§            fs::create_dir_all(parent)
§                .map_err(|e| format!(“failed to create directory {}: {e}”, parent.display()))?;
§        }
§    }
§
§    let data = serde_json::to_string_pretty(root)
§        .map_err(|e| format!(“failed to serialize JSON: {e}”))?;
§
§    fs::write(path, data).map_err(|e| format!(“failed to write state file {state_file}: {e}”))?;
§    Ok(())
§}
§
§fn ensure_object_root(root: &mut Value) -> Result<(), String> {
§    if root.is_null() {
§        *root = json!({});
§        return Ok(());
§    }
§
§    if !root.is_object() {
§        return Err(“state file root must be a JSON object”.into());
§    }
§
§    Ok(())
§}
§
§fn parse_value(s: &str) -> Value {
§    // Simple heuristic: try bool, then number, otherwise string.
§    if let Ok(b) = s.parse::() {
§        return Value::Bool(b);
§    }
§    if let Ok(i) = s.parse::() {
§        return Value::Number(i.into());
§    }
§    if let Ok(f) = s.parse::() {
§        if let Some(num) = serde_json::Number::from_f64(f) {
§            return Value::Number(num);
§        }
§    }
§    Value::String(s.to_string())
§}
§
§fn get_by_key_path<‘a>(root: &‘a Value, key_path: &str) -> Option<&‘a Value> {
§    let mut current = root;
§    for key in key_path.split(’.’) {
§        current = current.get(key)?;
§    }
§    Some(current)
§}
§
§fn set_by_key_path(root: &mut Value, key_path: &str, new_value: Value) -> Result<(), String> {
§    let mut current = root;
§    let mut segments = key_path.split(’.’).peekable();
§
§    while let Some(seg) = segments.next() {
§        if segments.peek().is_none() {
§            // Last segment: set value.
§            if let Value::Object(map) = current {
§                map.insert(seg.to_string(), new_value);
§                return Ok(());
§            } else {
§                return Err(format!(
§                    “cannot set key on non-object at segment ‘{seg}’ in path ‘{key_path}’”
§                ));
§            }
§        } else {
§            // Intermediate segment: ensure object and descend.
§            if !current.get(seg).is_some() {
§                if let Value::Object(map) = current {
§                    map.insert(seg.to_string(), json!({}));
§                } else {
§                    return Err(format!(
§                        “non-object encountered at segment ‘{seg}’ in path ‘{key_path}’”
§                    ));
§                }
§            }
§
§            let next = current.get_mut(seg).ok_or_else(|| {
§                format!(“failed to descend into segment ‘{seg}’ in path ‘{key_path}’”)
§            })?;
§
§            if !next.is_object() {
§                *next = json!({});
§            }
§
§            current = next;
§        }
§    }
§
§    Err(“empty key path is not allowed”.into())
§}
§
§fn log_manual_set(operation: &str, key_path: &str, value: &str, state_file: &str) -> Result<(), String> {
§    // Build a concise, syslog-friendly message.
§    // Example:
§    //   umrs-state set system_metadata.purpose=“Production Guard” state_file=/var/lib/umrs/umrs-state.json
§    let msg = format!(
§        “{} {} {}="{}" state_file={}”,
§        operation,
§        key_path,
§        “value”,
§        value,
§        state_file
§    );
§
§    // Use the system logger command so the message goes through syslog/rsyslog.
§    let status = Command::new(“logger”)
§        .arg(”-t”)
§        .arg(“umrs-state”)
§        .arg(msg)
§        .status()
§        .map_err(|e| format!(“failed to invoke logger: {e}”))?;
§
§    if !status.success() {
§        return Err(format!(“logger exited with status: {status}”));
§    }
§
§    Ok(())
§}
