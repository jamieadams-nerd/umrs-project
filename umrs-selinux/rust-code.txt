Rust mcstrans


Absolutely. Below is the entire Rust example again, including:
	1.	Cargo.toml
	2.	src/main.rs

Every single line is prefixed with the section symbol (ยง) exactly as you requested, and the content is pure plain text so you can paste it directly into files.

โธป

๐ฆ Cargo.toml (prefixed with ยง)

ยง [package]
ยง name = โumrs_label_lookupโ
ยง version = โ0.1.0โ
ยง edition = โ2021โ
ยง
ยง [dependencies]
ยง serde = { version = โ1.0โ, features = [โderiveโ] }
ยง serde_json = โ1.0โ
ยง anyhow = โ1.0โ
ยง clap = { version = โ4.5โ, features = [โderiveโ] }

โธป

๐ฆ src/main.rs (prefixed with ยง)

ยง use std::fs;
ยง use std::path::PathBuf;
ยง use clap::Parser;
ยง use serde::Deserialize;
ยง use anyhow::{Result, Context};
ยง
ยง #[derive(Debug, Deserialize)]
ยง struct SensitivityLevel {
ยง     name: String,
ยง     description: String,
ยง     handling: String,
ยง }
ยง
ยง #[derive(Debug, Deserialize)]
ยง struct Category {
ยง     abbreviation: String,
ยง     description: String,
ยง     handling: String,
ยง }
ยง
ยง #[derive(Debug, Deserialize)]
ยง struct UmrsMetadata {
ยง     sensitivity_levels: Vec,
ยง     categories: Vec,
ยง }
ยง
ยง #[derive(Parser, Debug)]
ยง #[command(version, about = โUMRS Sensitivity & Category Lookup Utilityโ)]
ยง struct Args {
ยง     /// Path to the JSON metadata file
ยง     #[arg(short, long)]
ยง     metadata: PathBuf,
ยง
ยง     /// Query a sensitivity level (example: S4)
ยง     #[arg(short = โsโ, long)]
ยง     sensitivity: Option,
ยง
ยง     /// Query a category abbreviation (example: PRIV_GEN or EXPORT)
ยง     #[arg(short = โcโ, long)]
ยง     category: Option,
ยง
ยง     /// List all known metadata
ยง     #[arg(short = โlโ, long)]
ยง     list: bool,
ยง }
ยง
ยง fn main() -> Result<()> {
ยง     let args = Args::parse();
ยง
ยง     // Load JSON file
ยง     let data = fs::read_to_string(&args.metadata)
ยง         .with_context(|| format!(โFailed to read {:?}โ, args.metadata))?;
ยง
ยง     let meta: UmrsMetadata = serde_json::from_str(&data)?;
ยง
ยง     // List mode
ยง     if args.list {
ยง         println!(โKnown Sensitivity Levels:โ);
ยง         for s in &meta.sensitivity_levels {
ยง             println!(โ  {} - {}โ, s.name, s.description);
ยง         }
ยง         println!(โ\nKnown Categories:โ);
ยง         for c in &meta.categories {
ยง             println!(โ  {} - {}โ, c.abbreviation, c.description);
ยง         }
ยง         return Ok(());
ยง     }
ยง
ยง     // Sensitivity lookup
ยง     if let Some(squery) = args.sensitivity {
ยง         for s in &meta.sensitivity_levels {
ยง             if s.name.eq_ignore_ascii_case(&squery) {
ยง                 println!(โSensitivity Level: {}โ, s.name);
ยง                 println!(โDescription: {}โ, s.description);
ยง                 println!(โHandling: {}โ, s.handling);
ยง                 return Ok(());
ยง             }
ยง         }
ยง         println!(โNo sensitivity level โ{}โ found.โ, squery);
ยง     }
ยง
ยง     // Category lookup
ยง     if let Some(cquery) = args.category {
ยง         for c in &meta.categories {
ยง             if c.abbreviation.eq_ignore_ascii_case(&cquery) {
ยง                 println!(โCategory: {}โ, c.abbreviation);
ยง                 println!(โDescription: {}โ, c.description);
ยง                 println!(โHandling: {}โ, c.handling);
ยง                 return Ok(());
ยง             }
ยง         }
ยง         println!(โNo category โ{}โ found.โ, cquery);
ยง     }
ยง
ยง     Ok(())
ยง }

โธป

โ๏ธ This version is:
	โข	Fully prefixed with ยง on every line
	โข	In pure plain text (no formatting blocks, no markup)
	โข	Ready for copy/paste into:
	โข	Cargo.toml
	โข	src/main.rs
	โข	Matches our JSON-based metadata lookup design
	โข	Clean, idiomatic Rust using clap, serde, and anyhow

โธป

If youโd like, I can next:

โ Generate the matching JSON metadata file (prefixed with ยง)
โ Add file-label lookup by reading SELinux contexts
โ Add colored or formatted output
โ Build the man page or README for the tool

Just tell me what you want next.
