Extra functions

Hereâ€™s a small, self-contained logging suite you can drop into the existing HA-Sign Bash script. It logs to syslog via logger with a default facility of authpriv and a tag of ha-sign. It supports info, notice, warning, and error levels so you can distinguish normal lifecycle events (e.g., â€œcreated new AUDIT keyâ€) from failures.

All script lines are prefixed with the section symbol, as you requested.

Â§###############################################################################
Â§# Logging configuration and helpers
Â§###############################################################################
Â§
Â§# Default syslog tag and facility for HA-Sign events.
Â§# You can override these at runtime:
Â§#   HA_SIGN_LOG_TAG=â€œmy-tagâ€ HA_SIGN_LOG_FACILITY=â€œlocal3â€ ./ha-sign.sh â€¦
Â§: â€œ${HA_SIGN_LOG_TAG:=ha-sign}â€
Â§: â€œ${HA_SIGN_LOG_FACILITY:=authpriv}â€
Â§
Â§# _log_syslog LEVEL MESSAGEâ€¦
Â§# LEVEL is one of: info, notice, warning, err, crit, alert, emerg
Â§# MESSAGE is the text to send to syslog.
Â§_log_syslog() {
Â§    local _level _msg
Â§    _level=â€$1â€
Â§    shift
Â§    _msg=â€$*â€
Â§
Â§    # If logger is not available, fail silently rather than breaking the script.
Â§    if command -v logger >/dev/null 2>&1; then
Â§        logger -p â€œ${HA_SIGN_LOG_FACILITY}.${_level}â€ 
Â§               -t â€œ${HA_SIGN_LOG_TAG}â€ 
Â§               â€“ â€œ${_msg}â€
Â§    fi
Â§}
Â§
Â§# Public logging helpers for common levels.
Â§log_info() {
Â§    _log_syslog info â€œ$@â€
Â§}
Â§
Â§log_notice() {
Â§    _log_syslog notice â€œ$@â€
Â§}
Â§
Â§log_warn() {
Â§    _log_syslog warning â€œ$@â€
Â§}
Â§
Â§log_error() {
Â§    _log_syslog err â€œ$@â€
Â§}
Â§
Â§###############################################################################
Â§# Example usage inside HA-Sign key-management functions
Â§###############################################################################
Â§
Â§# After successfully creating a new AUDIT signing key:
Â§#   log_notice â€œCreated new AUDIT signing key at ${AUDIT_KEY_PATH} (alg=${KEY_ALG}, bits=${KEY_BITS}, expires=${KEY_EXPIRES})â€
Â§#
Â§# After successfully rotating the LOG signing key:
Â§#   log_notice â€œRotated LOG signing key: old=${OLD_LOG_KEY_ID}, new=${NEW_LOG_KEY_ID}, archive=${ARCHIVE_DIR}â€
Â§#
Â§# On a validation failure or error condition:
Â§#   log_error â€œKey validation failed for ${KEY_PATH}: ${REASON}â€
Â§#
Â§# On a non-fatal warning (e.g., key close to expiration but still valid):
Â§#   log_warn â€œKey ${KEY_PATH} expires soon on ${EXPIRY_DATE} (threshold=${WARN_DAYS} days)â€

How this ties into your design:
	â€¢	For every successful lifecycle event (init, rotate, archive, report generation), call log_notice with enough detail for an auditor: what key, what role (AUDIT, LOG, ARCHIVE, etc.), algorithm, key length, expiration, and where itâ€™s stored.
	â€¢	For non-fatal but important conditions (about-to-expire keys, missing optional keys), call log_warn.
	â€¢	For hard failures (could not create key, could not archive, integrity check failed), call log_error.

Because the facility and tag are configurable via HA_SIGN_LOG_FACILITY and HA_SIGN_LOG_TAG, admins can route these messages to a dedicated file (e.g., /var/log/ha-sign.log) using rsyslog/journald configuration, while still having a consistent, auditable trail of all key management operations.

enscript ha-sign-report.txt \
  --font=Courier10 \
  --margins=72:72:72:72 \
  --header='HA-SIGN | Key Inventory Report | Page $% of $=' \
  --footer='Generated: $(date -u) UTC | Host: $(hostname)' \
  --line-numbers=1 \
  -o - | ps2pdf - ha-sign-report.pdf


Short answer: there is no perfect, fully-automatic way to know if the terminal can actually â€œdrawâ€ a given emoji, but you can get very close to â€œsafe enoughâ€ with a couple of checks and a fallback.

What you can reliably test
	1.	Is stdout a real terminal?

If your report is going to a file or pipe, you probably donâ€™t want emoji anyway.

Â§ if [ ! -t 1 ]; then
Â§     # stdout is not a terminal (probably a pipe or file)
Â§     use_emoji=0
Â§ fi
	2.	Is the environment UTF-8?

If the userâ€™s locale is not UTF-8, sending emoji is likely to produce mojibake or â€œ??â€.

A simple check:

Â§ _locale=â€${LC_ALL:-${LC_CTYPE:-$LANG}}â€
Â§ case â€œ$_localeâ€ in
Â§     UTF-8|utf8) utf8_ok=1 ;;
Â§     *)              utf8_ok=0 ;;
Â§ esac

If utf8_ok is 0, do not use emoji.
	3.	Does the system treat the emoji as a single character?

This doesnâ€™t prove the font supports it, but it proves libc and locale can handle it. You can use wc -m:

Â§ if printf â€˜ğŸ§‘â€ğŸ’»â€™ | wc -m | grep -qx â€˜1â€™; then
Â§     emoji_char_ok=1
Â§ else
Â§     emoji_char_ok=0
Â§ fi

If that returns 1 character, your locale/runtime are Unicode-aware enough that using emoji is reasonably safe. If it returns 4, 5, or errors, donâ€™t use emoji.

Putting it together in your script

Hereâ€™s a small helper you can drop into the key-signing manager script:

Â§ ha_supports_emoji()
Â§ {
Â§     # 1) stdout must be a TTY
Â§     if [ ! -t 1 ]; then
Â§         return 1
Â§     fi
Â§
Â§     # 2) allow explicit override: HA_SIGN_NO_EMOJI=1 -> force off
Â§     if [ â€œ${HA_SIGN_NO_EMOJI:-0}â€ -eq 1 ]; then
Â§         return 1
Â§     fi
Â§
Â§     # 3) require UTF-8 locale
Â§     _loc=â€${LC_ALL:-${LC_CTYPE:-$LANG}}â€
Â§     case â€œ$_locâ€ in
Â§         UTF-8|utf8) ;;
Â§         *) return 1 ;;
Â§     esac
Â§
Â§     # 4) check that the emoji is treated as a single character
Â§     if printf â€˜ğŸ§‘â€ğŸ’»â€™ | wc -m | grep -qx â€˜1â€™; then
Â§         return 0
Â§     else
Â§         return 1
Â§     fi
Â§ }

Then, when printing your report header:

Â§ if ha_supports_emoji; then
Â§     icon=â€œğŸ§‘â€ğŸ’»â€
Â§ else
Â§     icon=â€[OP]â€
Â§ fi
Â§ printf â€˜%s  High-Assurance Signing Key Report\nâ€™ â€œ$iconâ€

Why this still isnâ€™t perfect

Even with all that:
	â€¢	A terminal may be UTF-8 and still use a font that doesnâ€™t include that emoji, in which case youâ€™ll see an empty box or a tofu square.
	â€¢	There is no standard â€œtell me if you can render U+1F9D1 U+200D U+1F4BB correctlyâ€ escape sequence.

So the reality is:
	â€¢	You can robustly gate on:
	â€¢	â€œIs this a real terminal?â€
	â€¢	â€œIs this UTF-8?â€
	â€¢	â€œDoes libc see this as a valid character?â€
	â€¢	Beyond that, the last tiny bit (actual glyph shape) is out of your control.

Pragmatic recommendation for your project
	1.	Use the ha_supports_emoji() style check as a gate.
	2.	Add an environment override:
	â€¢	HA_SIGN_NO_EMOJI=1 to force ASCII.
	3.	In your operatorâ€™s guide, document:
	â€¢	â€œThe tool will use emoji if stdout is a UTF-8 terminal and the environment appears to support the characters; operators can disable emoji via HA_SIGN_NO_EMOJI=1 if they see rendering issues.â€

That gives admins exactly what you want: an â€œas automatic as possibleâ€ test, but with a clear, simple escape hatch when a particular terminal doesnâ€™t behave.
