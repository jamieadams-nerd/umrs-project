Chain sign and verify

Here’s a prototype that does both:
	•	signs a rotated audit log and updates a simple chain file
	•	verifies:
	•	a single log (signature + hash)
	•	the entire chain (all logs, sequence + linkage)

I’ll assume:
	•	audit logs: /var/log/audit/audit.log, audit.log.1, audit.log.2, …
	•	key root: /etc/pki/ha-sign
	•	private key: /etc/pki/ha-sign/auditd/private/auditd_signing_key
	•	public key: /etc/pki/ha-sign/auditd/public/auditd_signing_key.pub
	•	chain index: /var/lib/ha-sign/auditd-chain/chain.db
	•	signatures live next to the logs with “.sig” appended

You can tweak those paths/names easily in the config block.

As requested, every script line is prefixed with the section symbol (§) so you can paste and then strip it.

Script name example: ta_audit_sign.sh

§#!/usr/bin/env bash
§
§# ta_audit_sign.sh
§# High-assurance prototype for signing and verifying auditd log files
§# - Sign a log file and append it to a simple chained index
§# - Verify a single log (signature + hash)
§# - Verify the entire chain
§
§set -euo pipefail
§
§# —————————–
§# Configuration
§# —————————–
§
§# Where auditd keeps its logs
§AUDIT_LOG_DIR=”/var/log/audit”
§
§# Root for signing keys
§KEY_ROOT=”/etc/pki/ha-sign”
§AUDIT_KEY_NAME=“auditd_signing_key”
§
§# Private and public key locations
§PRIVKEY=”${KEY_ROOT}/auditd/private/${AUDIT_KEY_NAME}”
§PUBKEY=”${KEY_ROOT}/auditd/public/${AUDIT_KEY_NAME}.pub”
§
§# Where we keep chain metadata
§CHAIN_DIR=”/var/lib/ha-sign/auditd-chain”
§CHAIN_DB=”${CHAIN_DIR}/chain.db”
§
§# OpenSSL digest algorithm
§DIGEST_ALG=“sha256”
§
§# —————————–
§# Utility functions
§# —————————–
§
§usage() {
§    cat <<EOF
§Usage:
§  $0 sign 
§  $0 verify-file 
§  $0 verify-chain
§
§Examples:
§  $0 sign /var/log/audit/audit.log.1
§  $0 verify-file /var/log/audit/audit.log.1
§  $0 verify-chain
§EOF
§}
§
§ensure_setup() {
§    # Require root (or at least effective root) for now
§    if [ “$(id -u)” -ne 0 ]; then
§        echo “ERROR: This script must be run as root.” >&2
§        exit 1
§    fi
§
§    mkdir -p “${CHAIN_DIR}”
§
§    if [ ! -r “${PRIVKEY}” ]; then
§        echo “ERROR: Private key not found or not readable: ${PRIVKEY}” >&2
§        exit 1
§    fi
§
§    if [ ! -r “${PUBKEY}” ]; then
§        echo “ERROR: Public key not found or not readable: ${PUBKEY}” >&2
§        exit 1
§    fi
§
§    # Create chain DB if it does not exist
§    if [ ! -f “${CHAIN_DB}” ]; then
§        touch “${CHAIN_DB}”
§        chmod 600 “${CHAIN_DB}”
§    fi
§}
§
§# Compute SHA-256 of a file (hex only)
§file_sha256() {
§    local f=”$1”
§    openssl dgst -”${DIGEST_ALG}” -r “${f}” | awk ‘{print $1}’
§}
§
§# Get last sequence number from CHAIN_DB (or 0 if empty)
§get_last_seq() {
§    if [ ! -s “${CHAIN_DB}” ]; then
§        echo “0”
§        return
§    fi
§    tail -n 1 “${CHAIN_DB}” | awk -F’|’ ‘{print $1}’
§}
§
§# Get last hash from CHAIN_DB (or “NONE” if empty)
§get_last_hash() {
§    if [ ! -s “${CHAIN_DB}” ]; then
§        echo “NONE”
§        return
§    fi
§    tail -n 1 “${CHAIN_DB}” | awk -F’|’ ‘{print $3}’
§}
§
§# Find a chain entry by log path
§# Output the line or nothing if not found
§find_chain_entry_for_log() {
§    local log_path=”$1”
§    grep -F “|${log_path}|” “${CHAIN_DB}” || true
§}
§
§# —————————–
§# Signing
§# —————————–
§
§sign_log() {
§    local logfile=”$1”
§
§    ensure_setup
§
§    if [ ! -f “${logfile}” ]; then
§        echo “ERROR: Log file not found: ${logfile}” >&2
§        exit 1
§    fi
§
§    # Normalize path
§    logfile=”$(readlink -f “${logfile}”)”
§
§    # Signature file lives next to the log
§    local sigfile=”${logfile}.sig”
§
§    if [ -f “${sigfile}” ]; then
§        echo “WARNING: Signature file already exists, overwriting: ${sigfile}” >&2
§    fi
§
§    # Compute hash of the log
§    local log_hash
§    log_hash=”$(file_sha256 “${logfile}”)”
§
§    # Sign the log contents (detached signature)
§    openssl dgst -”${DIGEST_ALG}” -sign “${PRIVKEY}” -out “${sigfile}” “${logfile}”
§    chmod 600 “${sigfile}”
§
§    # Chain data
§    local last_seq last_hash new_seq prev_hash
§    last_seq=”$(get_last_seq)”
§    last_hash=”$(get_last_hash)”
§
§    if [ “${last_hash}” = “NONE” ]; then
§        prev_hash=“NONE”
§    else
§        prev_hash=”${last_hash}”
§    fi
§
§    new_seq=$((last_seq + 1))
§
§    # Append chain record:
§    # seq|log_path|log_sha256|sig_path|prev_log_sha256
§    printf ‘%s|%s|%s|%s|%s\n’ 
§        “${new_seq}” “${logfile}” “${log_hash}” “${sigfile}” “${prev_hash}” >> “${CHAIN_DB}”
§
§    echo “Signed ${logfile}”
§    echo “  Signature: ${sigfile}”
§    echo “  Hash:      ${log_hash}”
§    echo “  Chain seq: ${new_seq}, prev_hash=${prev_hash}”
§}
§
§# —————————–
§# Verification: single file
§# —————————–
§
§verify_file() {
§    local logfile=”$1”
§
§    ensure_setup
§
§    if [ ! -f “${logfile}” ]; then
§        echo “ERROR: Log file not found: ${logfile}” >&2
§        exit 1
§    fi
§
§    logfile=”$(readlink -f “${logfile}”)”
§    local sigfile=”${logfile}.sig”
§
§    if [ ! -f “${sigfile}” ]; then
§        echo “ERROR: Signature file not found: ${sigfile}” >&2
§        exit 1
§    fi
§
§    # Verify signature first
§    if ! openssl dgst -”${DIGEST_ALG}” -verify “${PUBKEY}” -signature “${sigfile}” “${logfile}” >/dev/null 2>&1; then
§        echo “FAIL: Signature verification FAILED for ${logfile}” >&2
§        exit 1
§    fi
§
§    echo “OK: Signature verification succeeded for ${logfile}”
§
§    # If the file appears in the chain, also verify hash against the chain record
§    local entry
§    entry=”$(find_chain_entry_for_log “${logfile}”)”
§    if [ -n “${entry}” ]; then
§        local chain_seq chain_path chain_hash chain_sig chain_prev
§        IFS=’|’ read -r chain_seq chain_path chain_hash chain_sig chain_prev <<EOF
§${entry}
§EOF
§
§        local current_hash
§        current_hash=”$(file_sha256 “${logfile}”)”
§
§        if [ “${current_hash}” != “${chain_hash}” ]; then
§            echo “FAIL: Hash mismatch for ${logfile}” >&2
§            echo “  Chain hash:   ${chain_hash}” >&2
§            echo “  Current hash: ${current_hash}” >&2
§            exit 1
§        fi
§
§        echo “OK: Hash matches chain record for ${logfile} (seq=${chain_seq})”
§    else
§        echo “NOTE: ${logfile} is not present in ${CHAIN_DB}; chain linkage not checked.”
§    fi
§}
§
§# —————————–
§# Verification: entire chain
§# —————————–
§
§verify_chain() {
§    ensure_setup
§
§    if [ ! -s “${CHAIN_DB}” ]; then
§        echo “Chain database is empty: ${CHAIN_DB}”
§        exit 0
§    fi
§
§    local prev_seq=”” prev_hash=””
§    local line
§
§    echo “Verifying full chain from ${CHAIN_DB} …”
§
§    while IFS= read -r line; do
§        [ -z “${line}” ] && continue
§
§        local seq log_path log_hash sig_path prev_log_hash
§        IFS=’|’ read -r seq log_path log_hash sig_path prev_log_hash <<EOF
§${line}
§EOF
§
§        echo “Checking seq=${seq} log=${log_path}”
§
§        if [ ! -f “${log_path}” ]; then
§            echo “  FAIL: Missing log file: ${log_path}” >&2
§            exit 1
§        fi
§        if [ ! -f “${sig_path}” ]; then
§            echo “  FAIL: Missing signature file: ${sig_path}” >&2
§            exit 1
§        fi
§
§        # 1) Verify signature
§        if ! openssl dgst -”${DIGEST_ALG}” -verify “${PUBKEY}” -signature “${sig_path}” “${log_path}” >/dev/null 2>&1; then
§            echo “  FAIL: Signature verification FAILED” >&2
§            exit 1
§        fi
§
§        # 2) Verify hash matches the chain record
§        local current_hash
§        current_hash=”$(file_sha256 “${log_path}”)”
§        if [ “${current_hash}” != “${log_hash}” ]; then
§            echo “  FAIL: Hash mismatch” >&2
§            echo “    Chain hash:   ${log_hash}” >&2
§            echo “    Current hash: ${current_hash}” >&2
§            exit 1
§        fi
§
§        # 3) Verify linkage to previous record
§        if [ -n “${prev_seq}” ]; then
§            # For the first record, prev_log_hash may be “NONE”.
§            if [ “${prev_log_hash}” != “NONE” ] && [ “${prev_log_hash}” != “${prev_hash}” ]; then
§                echo “  FAIL: Chain link mismatch at seq=${seq}” >&2
§                echo “    Expected prev_hash: ${prev_log_hash}” >&2
§                echo “    Actual prev_hash:   ${prev_hash}” >&2
§                exit 1
§            fi
§        fi
§
§        echo “  OK”
§
§        prev_seq=”${seq}”
§        prev_hash=”${log_hash}”
§    done < “${CHAIN_DB}”
§
§    echo “Full chain verification: OK”
§}
§
§# —————————–
§# Main
§# —————————–
§
§if [ “$#” -lt 1 ]; then
§    usage
§    exit 1
§fi
§
§cmd=”$1”
§shift || true
§
§case “${cmd}” in
§    sign)
§        if [ “$#” -ne 1 ]; then
§            usage
§            exit 1
§        fi
§        sign_log “$1”
§        ;;
§    verify-file)
§        if [ “$#” -ne 1 ]; then
§            usage
§            exit 1
§        fi
§        verify_file “$1”
§        ;;
§    verify-chain)
§        if [ “$#” -ne 0 ]; then
§            usage
§            exit 1
§        fi
§        verify_chain
§        ;;
§    *)
§        echo “Unknown command: ${cmd}” >&2
§        usage
§        exit 1
§        ;;
§esac

How to use (once you strip the leading “§” characters):
	1.	Sign a rotated audit log (e.g., from logrotate):

	•	After rotation (audit.log → audit.log.1):
	•	ta_audit_sign.sh sign /var/log/audit/audit.log.1

	2.	Verify a single log:

	•	ta_audit_sign.sh verify-file /var/log/audit/audit.log.1

	3.	Verify the chain:

	•	ta_audit_sign.sh verify-chain

If you want, the next step can be:
	•	adjust paths/key names to exactly match your HA-Sign layout
	•	add SELinux contexts and perms (e.g., CHAIN_DIR as root:root, 0700)
	•	later move this logic into the stricter HA-Sign project with no external config, just a small set of well-known locations and subcommands.

